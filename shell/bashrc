#!/bin/bash

# .bashrc by Alexander Olzem

# Disable infos relating sourcing of external files
# shellcheck disable=SC1091
# shellcheck disable=SC1090
# Disable declare and assign separately
# shellcheck disable=SC2155

# Return if not interactive
[[ $- != *i* ]] && return

# Source bash-completion
[[ -f /usr/share/bash-completion/bash_completion ]] && \
  . /usr/share/bash-completion/bash_completion

__ps1() {
  # colors
  local x='\[\017\]'     # reset
  local n='\[\033[0m\]'  # normal
  local r='\[\033[0;91m\]' # red
  local g='\[\033[0;92m\]' # green
  local b='\[\033[0;94m\]' # blue
  local w='\[\033[0;97m\]' # white

  # check if user is root
  local U
  [[ "$(id -u)" -eq 0 ]] && U='#' && b=$r || U='$'

  # K8s info
  local k8sinfo

  # Check if k8sinfo is desired
  if [[ -n "$PS1_K8S_INFO" ]]; then
    context=$(kubectl config current-context 2>/dev/null)
    namespace=$(kubens -c 2>/dev/null)
    [[ -n "$context" ]] && k8sinfo="$k8sinfo$b""Context: $w$context "
    [[ -n "$namespace" ]] && k8sinfo="$k8sinfo$b""Namespace: $w$namespace"
    [[ -n "$k8sinfo" ]] && k8sinfo="$w╔ $k8sinfo $w\n╚ "
  fi

  ## Git info
  local gitinfo

  # Check if current dir is a git repo
  local branch="$(git symbolic-ref --short HEAD 2>/dev/null)"
  if [[ -n "$branch" ]]; then
    # check if pre-commit is installed
    OLD_PWD="$PWD"
    while [[ -z "$(find "." -name '.git' -type d 2>/dev/null)" ]]; do
      cd .. || break
      [[ "$PWD" == "/" ]] && break
    done

    if [[ -n "$(find "$PWD" -name ".pre-commit-config.yaml" 2>/dev/null)" ]]; then
      [[ -f "$PWD/.git/hooks/pre-commit" ]] || printf "\033[0;91m%s\017\n" \
        "⚠ '.pre-commit-config.yaml' found but hooks are not yet installed" \
        "consider running 'pre-commit install'"
    fi
    cd "$OLD_PWD" || return

    # Get state of local repo
    local gitstatus="$(git status 2>/dev/null)"
    case "$(echo "$gitstatus" | awk 'FNR==2{print $4}')" in
      behind) gitinfo='-' ;;
      ahead) gitinfo='+' ;;
      *) gitinfo='' ;;
    esac

    # Check for uncommited changes
    [[ "$(echo "$gitstatus" | grep "^Changes")" != "" ]] && \
      gitinfo="$gitinfo*"

    # Check for untracked files
    [[ "$(echo "$gitstatus" | grep "^Untracked")" != "" ]] && \
      gitinfo="$gitinfo?"

    # Display Branch indicating red when on master/main or else green
    case "$branch" in
      master|main)
        [[ -z "$gitinfo" ]] && gitinfo="$r$branch" || \
          gitinfo="$r$branch $gitinfo" ;;
      *)
        [[ -z "$gitinfo" ]] && gitinfo="$g$branch" || \
          gitinfo="$g$branch $gitinfo" ;;
    esac
    gitinfo="$b($gitinfo$b) "
  fi

  # Final arrangement for prompt
  PS1="$x$k8sinfo$b\u@\h $w\w $gitinfo$b$U $n"
}

PROMPT_COMMAND="__ps1"

## Completion
# sudo
complete -cf sudo

# Kubernetes
[[ -n "$(command -v kubectl)" ]] && \
    . <(kubectl completion bash) && complete -F __start_kubectl k
[[ -n "$(command -v helm)" ]] && . <(helm completion bash)
[[ -n "$(command -v minikube)" ]] && . <(minikube completion bash)
[[ -n "$(command -v kind)" ]] && . <(kind completion bash)
[[ -n "$(command -v zarf)" ]] && . <(zarf completion bash 2> /dev/null)
[[ -n "$(command -v cilium)" ]] && . <(cilium completion bash 2> /dev/null)

_kube_contexts() {
  local cur;
  cur=${COMP_WORDS[COMP_CWORD]}
  if kubectl_out=$(kubectl config view -o template --template="{{ range .contexts  }}{{ .name }} {{ end }}"); then
    COMPREPLY=( $( compgen -W "${kubectl_out[*]}" -- "$cur" ) )
  fi
}

complete -F _kube_contexts kuc

# Terraform
complete -C /usr/bin/terraform terraform
complete -C /usr/bin/terraform tf

## Options
shopt -s checkwinsize
shopt -s expand_aliases   # Aliases in scripts
shopt -s autocd       # '..' -> 'cd ..'
shopt -s histappend     # Enable history appending instead of overwriting.

# Pretty-print man(1) pages.
export LESS_TERMCAP_md=$(printf '\33[1;34m')    # start bold      (blue)
export LESS_TERMCAP_me=$(printf '\33[0m')       # end bold
export LESS_TERMCAP_so=$(printf '\33[1;30;43m') # start standout  (yellow)
export LESS_TERMCAP_se=$(printf '\33[0m')       # end standout
export LESS_TERMCAP_us=$(printf '\33[1;32m')    # start underline (green)
export LESS_TERMCAP_ue=$(printf '\33[0m')       # end underline
export LESS="-j.5 -R"                           # center search hits

# Set GPG_TTY for GPG
export GPG_TTY="$(tty)"

# LS_COLORS
export LS_COLORS="$LS_COLORS:di=00;94"

# VI mode with ctrl-l
#set -o vi
#bind -m vi-command 'Control-l: clear-screen'
#bind -m vi-insert 'Control-l: clear-screen'
#bind 'set show-mode-in-prompt on'
#bind 'set vi-ins-mode-string \1\e[6 q\2'
#bind 'set vi-cmd-mode-string \1\e[5 q\2'
#bind -m vi-insert 'RETURN: "\e\n"'

# enable some aliases
[[ -e "$HOME/.config/aliases" ]] && . "$HOME/.config/aliases"

# source other system specific autorun scripts
[[ -e "$HOME/.localrc" ]] && . "$HOME/.localrc"
[[ -e "$HOME/.local/localrc" ]] && . "$HOME/.local/localrc"

# enable thefuck
[[ -n "$(command -v thefuck)" ]] && eval "$(thefuck --alias fuck)"

# pfetch
if [[ -n "$(command -v pfetch)" ]] && [[ "$TERM_PROGRAM" != "vscode" ]]; then
  PF_INFO="ascii title os kernel uptime wm shell memory" pfetch
fi

[[ -e /home/linuxbrew/.linuxbrew/bin/brew ]] && eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
