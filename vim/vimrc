" .vimrc by Alexander Olzem

"+---------------------------------------------------------------------------+
"| Plugins                                                                   |
"+---------------------------------------------------------------------------+

" Make sure plug is installed
if !empty(glob("~/.vim/autoload/plug.vim"))
    call plug#begin('~/.vim/plugged')
    " Colorscheme
    Plug 'morhetz/gruvbox'
    " Autocomplete
    Plug 'lifepillar/vim-mucomplete'
    Plug 'sheerun/vim-polyglot'
    " Vim-go
    Plug 'fatih/vim-go', { 'do': ':GoInstallBinaries' }
    if has('python3')
        Plug 'SirVer/ultisnips'
    endif
    " Nerd Tree
    Plug 'scrooloose/nerdtree'
    call plug#end()
endif

"+---------------------------------------------------------------------------+
"| Settings                                                                  |
"+---------------------------------------------------------------------------+

" Colors
if !empty(glob("~/.vim/plugged/gruvbox/colors/gruvbox.vim"))
    set bg=dark
    colorscheme gruvbox
    autocmd colorscheme * hi clear SpellBad
    autocmd colorscheme * hi SpellBad cterm=underline ctermfg=NONE ctermbg=NONE
else
    highlight LineNr ctermfg=darkgrey
    highlight ColorColumn ctermbg=darkgrey
endif

highlight Pmenu ctermbg=darkgrey ctermfg=white
highlight PmenuSel ctermbg=blue ctermfg=black

" Highlight trailing whitespace
hi TrailingWhitespace ctermbg=red guibg=red
call matchadd("TrailingWhitespace", '\v\s+$')

" Enable auto indenting
if has('filetype')
    filetype indent plugin on
endif

" Enable syntax highliting
if has('syntax')
    syntax on
endif

" Enable vim-µcomplete
if !empty(glob("~/.vim/plugged/vim-mucomplete/plugin/mucomplete.vim"))
    let g:mucomplete#enable_auto_at_startup = 1
endif

" vim-go options
if !empty(glob("~/.vim/plugged/vim-go/plugin/go.vim"))
    let g:go_fmt_fail_silently = 1
    let g:go_fmt_command = 'goimports'
    let g:go_fmt_autosave = 1           " :GoFmt on save
    let g:go_gopls_enabled = 1          " Needed for completion
    let g:go_highlight_types = 1
    let g:go_highlight_fields = 1
    let g:go_highlight_functions = 1
    let g:go_highlight_function_calls = 1
    let g:go_highlight_operators = 1
    let g:go_highlight_extra_types = 1
    let g:go_highlight_variable_declarations = 1
    let g:go_highlight_variable_assignments = 1
    let g:go_highlight_build_constraints = 1
    let g:go_highlight_diagnostic_errors = 1
    let g:go_highlight_diagnostic_warnings = 1
endif

let NERDTreeMinimalUI=1

" When editing a markdown file, enable spellcheck
augroup markdownSpell
    au!
    autocmd FileType markdown setlocal spell
    autocmd BufRead,BufNewFile *.md setlocal spell
    autocmd BufRead,BufNewFile *.MD setlocal spell
augroup END

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid, when inside an event handler
" (happens when dropping a file on gvim) and for a commit message (it's
" likely a different one than last time).
augroup vimStartup
    au!
    autocmd BufReadPost *
        \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |   exe "normal! g`\""
        \ | endif
augroup END

" Spellchecking for git commit messages
autocmd FileType gitcommit setlocal spell

" store backup, undo and swap files in temp directory
set undofile
set undolevels=1000
set undoreload=10000

set backup
set swapfile
set undodir=$HOME/.vim/tmp/undo
set backupdir=$HOME/.vim/tmp/backup
set directory=$HOME/.vim/tmp/swap

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif

" Keep buffers in background
set hidden

" Save .viminfo in .vim to keep home clean
set viminfo+=n~/.vim/viminfo

" Better command-line completion
set wildmenu

" Show partial commands in the last line of the screen
set showcmd

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
set nostartofline

" Display the cursor position on the last line of the screen or in the status
" line of a window
set ruler

" Always display the status line, even if only one window is displayed
set laststatus=2

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Don't annoy me pls
set visualbell t_vb=

" Set the command window height to 2 lines, to avoid many cases of having to
" "press <Enter> to continue"
set cmdheight=2

" Display line numbers on the left
set number

" Use <F11> to toggle between 'paste' and 'nopaste'
set pastetoggle=<F11>

" Set ruler at the right
set colorcolumn=80

" Indentation settings for using 4 spaces instead of tabs.
set tabstop=4 softtabstop=4 shiftwidth=4
set expandtab
set smartindent

" Mandatory for vim-µcomplete
set completeopt+=menuone
set completeopt+=noselect

" Shut off completion messages
set shortmess+=c

" Indentation settings for yaml (2 Spaces instead of tabs)
augroup yaml
    au!
    autocmd FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2
    autocmd FileType yaml set foldmethod=indent
    autocmd FileType yaml set nofoldenable
    autocmd BufRead,BufNewFile *.yml setlocal tabstop=2 softtabstop=2 shiftwidth=2
    autocmd BufRead,BufNewFile *.yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2
augroup END

" Indentation settings for shell scripts (2 Spaces instead of tabs)
augroup bash
    au!
    autocmd FileType bash,sh setlocal tabstop=2 softtabstop=2 shiftwidth=2
    autocmd BufRead,BufNewFile *.sh setlocal tabstop=2 softtabstop=2 shiftwidth=2
    autocmd BufRead,BufNewFile *.bash setlocal tabstop=2 softtabstop=2 shiftwidth=2
augroup END

augroup Makefile
    au!
    autocmd FileType Makefile set noexpandtab
augroup END

" Search options
set nohlsearch
set incsearch
set ignorecase
set smartcase
set scrolloff=4

" Search down in subfolders
set path+=**

"+---------------------------------------------------------------------------+
"| Remaps                                                                    |
"+---------------------------------------------------------------------------+

let mapleader=" "

" Behave Y!
nnoremap Y y$

" Center next / previous
nnoremap n nzzzv
nnoremap N Nzzzv

" Keep the cursor where it was after line concatination
nnoremap J mzJ`z

" Undo break points at end of sentences
inoremap , ,<c-g>u
inoremap . .<c-g>u
inoremap : :<c-g>u
inoremap ; ;<c-g>u
inoremap - -<c-g>u
inoremap ! !<c-g>u
inoremap ? ?<c-g>u

" Jumplist mutations
nnoremap <expr> k (v:count > 5 ? "m'" . v:count : "") . 'k'
nnoremap <expr> j (v:count > 5 ? "m'" . v:count : "") . 'j'

" Moving Text
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

nnoremap <leader>k :m .-2<CR>==
nnoremap <leader>j :m .+1<CR>==

nnoremap <leader>N :set number<CR>
nnoremap <leader>n :set nonumber<CR>

nnoremap <silent> <leader>t :NERDTreeToggle<CR>

"autocmd FileType go NERDTree

au FileType go nmap <leader>r :GoRun!<CR>
au FileType go nmap <leader>gt :GoTest!<CR>
au FileType go nmap <leader>v :GoVet!<CR>
au FileType go nmap <leader>b :GoBuild!<CR>
au FileType go nmap <leader>c :GoCoverageToggle<CR>
au FileType go nmap <leader>i :GoInfo<CR>
au FileType go nmap <leader>l :GoMetaLinter!<CR>

" Disable Arrow keys
" noremap <up> <NOP>
" noremap <down> <NOP>
" noremap <left> <NOP>
" noremap <right> <NOP>

" inoremap <up> <NOP>
" inoremap <down> <NOP>
" inoremap <left> <NOP>
" inoremap <right> <NOP>

